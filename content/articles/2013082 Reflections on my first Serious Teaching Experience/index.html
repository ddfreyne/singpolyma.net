---
title: Reflections on my first Serious Teaching Experience
date: 2013-03-23 01:22:24 Z
tags: ["Personal","Kwartzlab","Education"]
wordpress_path: /2013/03/reflections-on-my-first-serious-teaching-experience
---
It's no secret that I'm <a href="<%= @items['/articles/2008297 On Universities/index.html'].path %>">not impressed with the current state of University education</a>.  I've spent a long time griping about the various issues, and pointing out ways I would do it differently.  None of that makes any difference, however, until I actually do something about it.

While my issues are with post-secondary education generally, my primary expertise (especially of late) is in <a href="http://en.wikipedia.org/wiki/Computer_science">Computer Science</a> and <a href="http://en.wikipedia.org/wiki/Software_development">Software development</a>.  So, I developed <a href="https://github.com/singpolyma/cs-top-and-bottom">a curriculum</a>, found <a href="http://kwartzlab.ca">a community</a>, and started teaching a class.

Teaching one class does not constitute a solution, but it <em>does</em> provide a learning experience for me.  The class is over half done now, and in the rest of this post I will be examing things I have tried and what I have learned.

<h2>Hands-on Learning</h2>

Since my approach is focused entirely on education, I did not assign any exercizes early on.  I provided students with the tools needed to play with the concepts on their own, and set them free to hack.  This turned out to be <strong>too open-ended</strong>.  When encountering a new concept for the first time, many students simply had no concept of what direction they should take their explorations in.

I am now providing some concrete exercizes to the students, but really I need to find a way to integrate more hands-on learning into the class itself.  This is made more difficult because of the pacing I chose for this version.

<h2>Pacing</h2>

Probably the biggest experiment in this first version of the course is the pacing I am using.  The class is an overview of Computer Science from both the perspective of functional abstractions and low-level machine implementation.  It is designed to give students a flavour of what parts of Computer Science they might find interesting for further study.  I am doing the whole thing in <strong>8 weeks</strong>.

The amount of material I am covering would normally be covered in two or more <em>semesters</em> at a University.  Why am I doing this?  For two reasons: so that students have less time to get bogged down on individual details (since, as an overview course, this is not about depth), and also to find out how fast one can reasonably progress without hopelessly confusing students.

While I cannot be sure without more experiments, I am also beginning to suspect that the pacing <em>increases</em> student engagement (at least for the sorts of students I have solicited).  New material every single class means that students do not have an opportunity to tune out because "we already talked about this".

While the pacing is definitely hurting the students' ability to deeply absorb the subject matter, I conduct informal experiments periodically to determine understanding.  Students in general seem to be grasping concepts, and find themselves coming back up to speed on items they failed to retain quickly enough to demonstrate a level of penetration.

<h2>Students</h2>

For this course, primarily because of the pacing, I solicited students with prior knowledge of computer internals and programming.  I started out with a good mix of students from various backgrounds, but certain students (about half of the 10 I started with) dropped the course fairly early on.

Students who stuck with the course were precisely those students who had both enough knowledge of computer internals to handle the pace, and enough of a deficiency in prior experience with Computer Science-related material to be interested in an overview.  I hope to run both slower and more in-depth courses in the future in order to serve other sorts of students.

While prior knowledge of the basics seems to be helping the students' ability to comprehend new material, it also occassionally poses a distraction, since I cannot present any idea as strictly new.  I need to improve my ability to communicate an idea that is "new" in the context of a course, without speaking as though no one present has ever heard of it before.

<h2>From the Top and Bottom</h2>

The concept of my particular curriculum for this course is to start at the "most" abstract and "most" machine-specific concepts, and work inward.  This is in stark contrast to most first-year Computer Science courses, which start out in practical programming, move on to machine specifics, and then later on do algorithms and (maybe) more abstract (actual) Computer Science.

Students have indeed struggled with the seemingly-abstract concepts, especially early on when they may not yet even have a basis on which to understand "why they care" about the abstractions that are possible.  This is partly because of my failure to spur adequate hands-on learning, and partly because of the ordering.  On the other hand, the juxtaposition of abstractions and related implementation details has already more than once resulted in realizations about the nature of the abstractions ("that product type is just like a struct!")

<h2>Next Steps</h2>

I still have to finish teaching this class, and will report more at that time.  Some of my students (and also other members of the Kwartzlab community) have expressed interest in an Operating Systems implementation course, based on my <a href="/ipns/singpolyma.net/tags/singpolyma-kernel">Writing a Simple OS Kernel</a> series of posts.  I hope to run this course mid-summer, and structure it purely as a project course.  This should give me more experience with the ways that hands-on learning can be effectively brought directly into a class.

I am also excited about the idea of running other more in-depth courses, based on community interest.  From a "Computer Science for Programmers" side I would like to run a course I'm calling "Advance Abstractions" (dealing with advanced concepts in control flow and data modelling) and also a non-course structured as various talks by various contributors on specific data structures and algorithms.

I would also like to run the "slow version" of this same course, targetted at complete beginners.  The problem with this version is that it requires participants to have more time to dedicate to the course.  We'll see where that goes.
